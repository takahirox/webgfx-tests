<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js performance - instancing</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			color: #ffffff;
			font-family: Monospace;
			font-size: 13px;
			text-align: center;
			font-weight: bold;
			background-color: #000000;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
		}

		a {
			color: #ffffff;
		}

		#webglmessage a {
			color: #da0;
		}

		#notSupported {
			width: 50%;
			margin: auto;
			border: 2px red solid;
			margin-top: 20px;
			padding: 10px;
		}
	</style>
</head>
<body>

	<div id="container"></div>

	<script src="three.js"></script>

	<script>

		function loadOption( key ) {

			var options = location.href.split( '?' )[ 1 ];

			if ( ! options ) return null;

			var optionArray = options.split( '&' );

			for ( var i = 0, il = optionArray.length; i < il; i ++ ) {

				var tmp = optionArray[ i ].split( '=' );

				if ( tmp[ 0 ].toLowerCase() === key ) return tmp[ 1 ];

			}

			return null;

		}

		var objectNum = parseInt( loadOption( 'num' ) ) || 1000;

		var container;

		var camera, scene, renderer;

		var uniformTime = { value: 0.0 };

		var clock = new THREE.Clock();

		loadEnvMap();

		function loadEnvMap() {

			var path = 'textures/cube/Park2/';
			var format = '.jpg';
			new THREE.CubeTextureLoader().load( [
				path + 'posx' + format, path + 'negx' + format,
				path + 'posy' + format, path + 'negy' + format,
				path + 'posz' + format, path + 'negz' + format
			], function ( texture ) {

				init( texture );
				renderer.render( scene, camera );
				animate();

			} );

		}

		function init( envMap ) {

			container = document.getElementById( 'container' );

			camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
			camera.position.y = 40;
			camera.position.z = 80;
			camera.lookAt( new THREE.Vector3( 0.0, 10.0, 0.0 ) );

			scene = new THREE.Scene();
			scene.background = envMap;

			var light = new THREE.DirectionalLight( 0xffffff );
			light.position.set( 10, 10, 10 );
			scene.add( light );

			// geometry

			var baseGeometry = new THREE.SphereBufferGeometry( 1.0, 16, 12 );

			var velocities = [];
			var offsets = [];
			var colors = [];
			var roughnesses = [];
			var metallics = [];

			// instanced attributes

			for ( var i = 0; i < objectNum; i ++ ) {

				velocities.push( ( Math.random() - 0.5 ) * 10.0 );
				velocities.push( ( Math.random() - 0.5 ) * 10.0 );

				offsets.push( ( Math.random() - 0.5 ) * 80.0 );
				offsets.push( Math.random() * 40.0 + 5.0 );
				offsets.push( ( Math.random() - 0.5 ) * 80.0 );

				colors.push( Math.random() );
				colors.push( Math.random() );
				colors.push( Math.random() );

				roughnesses.push( Math.random() );
				metallics.push( Math.random() );

			}

			var geometry = new THREE.InstancedBufferGeometry();
			geometry.maxInstancedCount = objectNum;

			geometry.addAttribute( 'position', baseGeometry.getAttribute( 'position' ) );
			geometry.addAttribute( 'normal', baseGeometry.getAttribute( 'normal' ) );
			geometry.setIndex( baseGeometry.getIndex() );
			geometry.addAttribute( 'instanceOffset', new THREE.InstancedBufferAttribute( new Float32Array( offsets ), 3 ) );
			geometry.addAttribute( 'instanceVelocity', new THREE.InstancedBufferAttribute( new Float32Array( velocities ), 2 ) );
			geometry.addAttribute( 'instanceColor', new THREE.InstancedBufferAttribute( new Float32Array( colors ), 3 ) );
			geometry.addAttribute( 'instanceRoughness', new THREE.InstancedBufferAttribute( new Float32Array( roughnesses ), 1 ) );
			geometry.addAttribute( 'instanceMetallic', new THREE.InstancedBufferAttribute( new Float32Array( metallics ), 1 ) );

			// material

			var material = new THREE.MeshStandardMaterial( {
				color: 0xffffff,
				metalness: 1.0,
				roughness: 1.0,
				envMap: envMap
			} );

			material.onBeforeCompile = function ( shader ) {

				// console.log( shader.uniforms );
				// console.log( shader.vertexShader );
				// console.log( shader.fragmentShader );

				shader.uniforms.time = uniformTime;

				shader.vertexShader = shader.vertexShader
					.replace( '#include <common>\n',
						[ '#include <common>',
						  'attribute vec2 instanceVelocity;',
						  'attribute vec3 instanceOffset;',
						  'attribute vec3 instanceColor;',
						  'attribute float instanceRoughness;',
						  'attribute float instanceMetallic;',
						  'varying vec3 vInstanceColor;',
						  'varying float vInstanceRoughness;',
						  'varying float vInstanceMetallic;',
						  'uniform float time;'	].join( '\n' ) + '\n' )
					.replace( '#include <begin_vertex>\n',
						[ 'vec3 transformed = vec3( position ) + instanceOffset;',
						  'transformed.xz += instanceVelocity * time;',
						  'const float gravity = 9.8 * 10.0;',
						  'float initialY = instanceOffset.y;',
						  'float groundTime = sqrt( 2.0 * initialY / gravity );',
						  'float time2 = mod( time, groundTime * 2.0 );',
						  'if ( time2 > groundTime ) {',
						  '	time2 = groundTime * 2.0 - time2;',
						  '}',
						  'transformed.y -= 0.5 * gravity * pow( time2, 2.0 );',
						  'vInstanceColor = instanceColor;',
						  'vInstanceRoughness = instanceRoughness;',
						  'vInstanceMetallic = instanceMetallic;' ].join( '\n' ) + '\n' );

				shader.fragmentShader = shader.fragmentShader
					.replace( '#include <common>\n',
						[ '#include <common>',
						  'varying vec3 vInstanceColor;',
						  'varying float vInstanceMetallic;',
						  'varying float vInstanceRoughness;' ].join( '\n' ) + '\n' )
					.replace( 'vec4 diffuseColor = vec4( diffuse, opacity );\n',
						'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );\n' )
					.replace( '#include <metalnessmap_fragment>\n',
						'float metalnessFactor = metalness * vInstanceMetallic;\n' )
					.replace( '#include <roughnessmap_fragment>\n',
						'float roughnessFactor = roughness * vInstanceRoughness;\n' );

			}

			//

			var mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			//

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.gammaOutput = true;
			container.appendChild( renderer.domElement );

			//

			window.addEventListener( 'resize', onWindowResize, false );

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		//

		function animate() {

			requestAnimationFrame( animate );

			render();

		}

		function render() {

			uniformTime.value = ( uniformTime.value + clock.getDelta() ) % 60.0;

			renderer.render( scene, camera );

		}

	</script>

</body>

</html>
